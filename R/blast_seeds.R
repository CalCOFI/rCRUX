#' Wrapper function for blast_datatable that reads a data.frame from a path
#'
#' @description
#' blast_seeds uses [RCRUX.dev::blast_datatable()] to search against a blast
#' formatted database. It creates a directory at `working_dir` if one does not
#' already exist and generates `blast_seeds_output` and `.blast_seeds_save`
#' inside that directory. It passes `<working_dir>/.blast_seeds_save` to
#' [RCRUX.dev::blast_datatable()] as the save directory and generates files in
#' `rblast_seeds_output` recording the results of the blast.
#'
#' @details
#' # Saving data
#' The [rCRUX::blast_datatable()] call saves intermediate results and
#' metadata about the search as local files in the save directory generated by
#' blast_seeds. This allows the function to resume a partially
#' completed blast, mitigating the consequences of encountering an
#' error or experiencing other interruptions. To resume a partially completed
#' blast, supply the same seeds and working directory. See the documentation
#' of [rCRUX::blast_datatable()] for more information.
#'
#' @param seeds_output_path a path to a csv from get_seeds_local or get_seeds_remote
#' @param blast_db_path a directory containing a blast-formatted database
#' @param accession_taxa_sql_path a path to the accessionTaxa sql created by
#'        taxonomizr
#' @param working_dir a directory in which to save partial and complete output
#' @param metabarcode_name a prefix for the fasta
#' @param expand_vectors logical, determines whether to expand too_many_Ns
#'        and not_in db into real tables and write them in the output directory
#' @param warnings value to set the "warn" option to during the function call.
#'        On exit it returns to the previous value. Setting this argument to
#'        NULL will not change the option.
#' @param ... additional arguments passed to [RCRUX.dev::blast_datatable()]
#' @return NULL
#' @export
blast_seeds <- function(seeds_output_path, blast_db_path, accession_taxa_sql_path, working_dir,
                        metabarcode_name, expand_vectors = TRUE, warnings = 0, ...) {
  # So that run_blastdbcmd doesn't overwhelm the user with errors
  # Possibly we should discard the warnings from blastdb as it's entirely
  # expected to encounter so values that are not in the database.
  if (!is.null(warnings)) {
    old_warnings <- getOption("warn")
    on.exit(options(warn = old_warnings))
    options(warn = warnings)
  }

  output_dir <- paste(working_dir, "blast_seeds_output", sep = "/")
  save_dir <- paste(working_dir, "blast_seeds_save", sep = "/")
  dir.create(working_dir)
  dir.create(save_dir)
  dir.create(output_dir)
  blast_seeds <- read.csv(seeds_output_path)
  output_table <- blast_datatable(blast_seeds, save_dir, blast_db_path,
                                  accession_taxa_sql_path, ...)

  # Write output_table to dir/blast_seeds_output/summary.csv
  summary_csv_path <- paste(output_dir, "summary.csv", sep = "/")
  write.csv(output_table, file = summary_csv_path, row.names = FALSE)

  # Write a fasta
  get_fasta_no_hyp(output_table, output_dir, metabarcode_name)

  # Taxonomy file format (tidyr and dplyr)
  taxa_table <-  dplyr::select(output_table,accession, superkingdom, phylum, class, order, family, genus, species)
  taxa_table <-tidyr::unite(taxa_table,taxonomic_path, superkingdom:species, sep = ";", remove = TRUE, na.rm = FALSE)
  taxa_table <-dplyr::slice(taxa_table,-1)

  # Write the thing
  taxa_table_path <- paste0(output_dir, "/", metabarcode_name, "_taxonomy.txt")
  write.table(taxa_table, file = taxa_table_path, row.names = FALSE, col.names=FALSE, sep = "\t")

  # Count distinct taxonomic ranks - includes NA
  tax_rank_sum <- dplyr::summarise_at(output_table,c('phylum','class','order','family','genus','species'),dplyr::n_distinct)

  # Write output to blast_seeds_output
  tax_rank_sum_table_path <- paste0(output_dir, "/", metabarcode_name, "_unique_taxonomic_rank_counts.txt")
  write.table(tax_rank_sum, file = tax_rank_sum_table_path, row.names = FALSE, col.names=TRUE, sep = ",")


  # Read condensed vectors and expand them
  if (expand_vectors) {
    too_many_ns_path <- paste(save_dir, "too_many_ns.txt", sep = "/")
    too_many_ns_indices <- as.numeric(readLines(too_many_ns_path))
    too_many_ns <- blast_seeds[too_many_ns_indices, ]
    too_many_ns_csv_path <- paste(output_dir, "too_many_ns.csv", sep = "/")
    write.csv(too_many_ns, file = too_many_ns_csv_path, row.names = FALSE)

    blastdbcmd_failed_path <- paste(save_dir, "blastdbcmd_failed.txt", sep = "/")
    blastdbcmd_failed_indices <- as.numeric(readLines(blastdbcmd_failed_path))
    blastdbcmd_failed <- blast_seeds[blastdbcmd_failed_indices, ]
    blastdbcmd_failed_csv_path <- paste(output_dir, "blastdbcmd_failed.csv", sep = "/")
    write.csv(blastdbcmd_failed, file = blastdbcmd_failed_csv_path, row.names = FALSE)
  }
  unlink(save_dir, recursive=TRUE)
  return(NULL)
}

get_fasta_no_hyp <- function(dupt, file_out_dir, metabarcode_name) {
  dupt_no_hiyp <-  dplyr::mutate(dupt, sequence = gsub("-", "", sequence))
  fasta <- character(nrow(dupt_no_hiyp) * 2)
  fasta[c(TRUE, FALSE)] <- paste0(">", dupt_no_hiyp$accession)
  fasta[c(FALSE, TRUE)] <- dupt_no_hiyp$sequence
  writeLines(fasta, paste0(file_out_dir, "/", metabarcode_name, "_.fasta"))
}
